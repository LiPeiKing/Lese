## 内存划分

![img](https://pic1.zhimg.com/80/v2-9c7846ec6af555435850d2687cccb4a0_720w.jpg) 

### JDK1.8对比

我们的java代码经过了类加载到了JVM运行时候，就需要使用到多块内存空间，不同的空间存放不同的数据，配合代码流程，才能让程真正运行起来。

JVM内存划分在JDK1.8之后和之前是略有不同主要是将方法区调整为了元空间

JDK1.8之前：

![img](https:////upload-images.jianshu.io/upload_images/24515051-bb8c58287155c7f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

JDK1.8之后：

![img](https:////upload-images.jianshu.io/upload_images/24515051-cbf09d1adb3bf321.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

​    图上线程区的域的数据是私有的，其他区域的数据是共享的。



### 1、元空间

在 Java 8 里面不存在永久代了，取而代之的是元空间。

> 补充一下：方法区只是一个概念，永久代或者元空间是它的实现

#### 1.1、简介

> 元数据：描述数据的数据
> 例如一部电影，导演：---、主演：---、投资方：---，这些信息中的导演、主演、投资方就叫元数据，他们加一起描述了整部电影的详细数据

元空间是保存元数据的地方，如方法、字段、类、包的描述信息，这些信息可以用于创建文档、跟踪代码中的依赖性、执行编译时检查。

#### 1.2、意义

在方法区里面，由于方法区大小是启动时就设置好的，可以用默认的也可以手动指定： `-XX:MaxPermSize` ，但是他始终还是有限定大小的（触发永久代 OOM 后该大小会动态调整），也就是说会发生 OOM

此外永久代的 GC 特别难搞，严重影响 Full GC 的性能。于是抛弃永久代，使用元空间，从而解决这些问题

#### 1.3、元空间如何提高性能

1. 永久代里面的常量池都移到堆里面，只保存元数据，从而让 Full GC 不再关心方法区
2. 元空间使用直接内存，理论上系统内存有多大，元空间就可以有多大，不存在 OOM
3. 元空间有单独的元空间虚拟机执行内存分配与垃圾回收



#### 2、方法区（存放类）

​    方法区与堆一样，是各个线程共享内存区域，方法区也被称为非堆或者永久代。方法区在JDK1.8以前的版本，代表JVM的一块区域。主要存放.class文件里加载进来的类，同时也会存放一些类似常量池的东西在这个区域。 但是在JDK1.8之后这里就改名为MetaSpace(元空间)，主要还是用来存放各种类相关信息。

​    整个永久代有一个JVM本身设置的固定大小上限，无法进行调整。但是1.8后元空间使用的是直接内存，受本机内存的限制，内存溢出的几率比永久代小了很多

#### 3、运行时常量

  .class文件中除了存放类版本、字段、方法、接口等描述信息外、还有常量池（用于存放编译期生成的各种字面量和符号引用）， 运行时常量是方法区的一部分，受到方法区内存限制，当常量无法在申请到内存空间时候会抛出OutofMemoryError异常

#### 4、程序计数器（执行代码指令）

​    我们所开发的代码是.java文件是面向开发人员的，但是计算机是无法读懂的，所以就需要编译为.class字节码文件，字节码才是计算机可以理解的文件。字节码的指令会让程序执行各种操作。

![img](https:////upload-images.jianshu.io/upload_images/24515051-39ff437d9b7a389a.png?imageMogr2/auto-orient/strip|imageView2/2/w/658/format/webp)

​    程序计数器可以看作是当前线程所执行字节码指令的行号指示器，主要有两个作用

1.字节码解释器通过改变程序计数器，来依次读取需要执行的指令，从而实现代码的流程控制（顺序执行、选择、循环、异常处理）

2.多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来也能知道上次运行的位置。每条线程间的程序计数器是互不影响的，独立存储、也就是"线程私有"。

> ​    程序计数器是唯一一个不会出现OutofMemoryError的内存区域，生命周期是从线程的创建至线程的销毁。

#### 5、JAVA虚拟机栈

​    我们在方法中经常会定义一些局部变量，就会保存在JAVA的虚拟机栈中。JAVA虚拟机栈是由多个帧栈组成，如果线程执行了一个方法，那么就会对这个方法调用，创建一个对应的帧栈都包含（局部变量表、操作数栈、动态链接、方法出口等信息）。每一次函数调用就会有一个对应的帧栈被压入JAVA栈，每个函数调用结束后就会有一个帧栈被弹出，栈的顺序是先进后出

​    JAVA虚拟机栈也是私有的，生命周期也是从线程的创建至线程的销毁。虚拟机栈会出现两种错误：

> 1.StackOverFlowError: 如果虚拟栈的内存大小不允许动态扩展，那么当线程请求栈的深度大于java虚拟机栈的最大深度时，会抛出该异常
>
> 2.OutofMemoryError: 虚拟机栈的内存大小允许动态扩展，如果虚拟机在动态扩展栈时，无法申请到足够的内存空间，会抛出该异常

#### 6、本地方法栈

​    与JAVA虚拟机栈相似，区别：虚拟栈执行JAVA的方法，而本地方法栈是为虚拟机使用到的Native方法服务（在HotSpot虚拟机中与JAVA虚拟机栈合二为一）。栈的顺序是先进后出，也会产生两种异常

#### 7、堆

​    JAVA的堆内存是用来存放我们代码中创建的各种对象，是所有线程共享的一块区域。几乎所有的对象实例以及数组都是在这里分配内存，但是随着JIT动态编译技术的发展与逃逸分析技术的成熟，从JDK1.7开始已经默认开启了逃逸分析，如果某些方法的对象引用没有被返回或者是未被使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。堆的顺序是先进先出

​    JAVA堆是垃圾回收的主要区域，因此也叫GC堆。是最容易产生 OutOfMemoryError 异常，例如:

> 1.OutOfMemoryError: GC Overhead Limit Exceeded: 当JVM花费很长的时间执行垃圾回收，并且只能回收到很小的堆空间时，就会引发此异常
>
> 2.java.lang.OutOfMemoryError: Java heap space： 如果在新建对象时，堆内存空间存放不下，就会引发此异常（和配置的内存大小有关，与物理内存无关）

​    栈与堆都是JAVA用来存储数据的地方。栈的优势为存储比堆快，仅次于CPU中的寄存器，缺点是存在栈中的数据大小与生命期是确定的，缺乏灵活性。堆的优势可以动态的分配内存大小，生命期也是非固定的，缺点是需要在运行是进行动态分配，存取速度较慢

#### 8、直接内存

​    直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机的内存区域，但是这部分内存也被频繁使用到，也会导致OutOfMemoryError异常。本地内存不受java堆堆限制，但是会受到本机总内存大小及处理器寻址空间限制

​     在JDK1.4中加入的NIO(New Input/OutPut)类，引入了一种基于渠道（channel）与缓冲区（Buffer）的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在JAVA堆中的DirectByteBuffer对象作为这块的内存引用操作，这样避免了在Java堆与Native堆来回的复制数据，从而提高了性能



